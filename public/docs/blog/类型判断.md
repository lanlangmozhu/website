---
slug: 类型判断
title: 类型判断
excerpt: ## 类型判断   ####  typeof  #### instanceof  #### Object.prototype.toString.call()
date: 2025-12-18
author: 小菜权
readTime: 1 分钟
tags: []
category: blog
image: https://picsum.photos/seed/910/1200/600
---

## JavaScript 类型判断方法

在 JavaScript 中，准确判断变量的类型是一个常见需求。由于 JavaScript 的动态类型特性，类型判断变得尤为重要。本文将介绍几种常用的类型判断方法及其适用场景。

### typeof 操作符

`typeof` 是最常用的类型判断方法，可以判断基本数据类型：

```javascript
typeof 'string'        // 'string'
typeof 123            // 'number'
typeof true           // 'boolean'
typeof undefined      // 'undefined'
typeof Symbol()       // 'symbol'
typeof function(){}   // 'function'
typeof {}             // 'object'
typeof []             // 'object' (注意：数组也是 object)
typeof null           // 'object' (这是 JavaScript 的 bug)
```

#### typeof 的局限性

1. **无法区分数组和对象**: 都返回 `'object'`
2. **null 判断错误**: `typeof null` 返回 `'object'`
3. **无法判断具体对象类型**: 如 Date、RegExp 等

```javascript
// 问题示例
typeof [] === 'object'        // true
typeof {} === 'object'        // true
typeof null === 'object'      // true (错误)
typeof new Date() === 'object' // true
```

### instanceof 操作符

`instanceof` 用于判断对象是否是某个构造函数的实例：

```javascript
[] instanceof Array           // true
{} instanceof Object         // true
new Date() instanceof Date   // true
/abc/ instanceof RegExp      // true

// 继承关系
[] instanceof Object         // true (数组也是对象)
```

#### instanceof 的局限性

1. **只能判断对象类型**: 不能判断基本数据类型
2. **原型链问题**: 会沿着原型链查找
3. **跨窗口问题**: 不同 iframe 中的对象无法正确判断

```javascript
// 问题示例
'string' instanceof String   // false (基本类型)
new String('string') instanceof String // true

// 跨窗口问题
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;
const arr = new iframeArray();
arr instanceof Array; // false (不同窗口)
```

### Object.prototype.toString.call()

这是最准确的类型判断方法，可以判断所有类型：

```javascript
Object.prototype.toString.call('string')     // '[object String]'
Object.prototype.toString.call(123)          // '[object Number]'
Object.prototype.toString.call(true)          // '[object Boolean]'
Object.prototype.toString.call(undefined)     // '[object Undefined]'
Object.prototype.toString.call(null)          // '[object Null]'
Object.prototype.toString.call([])            // '[object Array]'
Object.prototype.toString.call({})            // '[object Object]'
Object.prototype.toString.call(new Date())    // '[object Date]'
Object.prototype.toString.call(/abc/)         // '[object RegExp]'
Object.prototype.toString.call(function(){})  // '[object Function]'
```

#### 封装通用类型判断函数

```javascript
function getType(value) {
  return Object.prototype.toString.call(value)
    .slice(8, -1)
    .toLowerCase();
}

getType('string')     // 'string'
getType([])           // 'array'
getType(null)         // 'null'
getType(new Date())   // 'date'
```

### Array.isArray()

专门用于判断数组，比 `instanceof` 更可靠：

```javascript
Array.isArray([])              // true
Array.isArray({})              // false
Array.isArray('string')        // false
Array.isArray(null)            // false

// 兼容性处理
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```

### 其他类型判断方法

#### 判断是否为 null 或 undefined

```javascript
// 方法 1: 使用 ==
value == null  // true if value is null or undefined

// 方法 2: 使用 ===
value === null || value === undefined

// 方法 3: 使用 typeof
typeof value === 'undefined' || value === null
```

#### 判断是否为数字

```javascript
function isNumber(value) {
  return typeof value === 'number' && !isNaN(value);
}

isNumber(123)        // true
isNumber('123')     // false
isNumber(NaN)        // false
isNumber(Infinity)  // true
```

#### 判断是否为纯对象（Plain Object）

```javascript
function isPlainObject(value) {
  return Object.prototype.toString.call(value) === '[object Object]' &&
         value.constructor === Object;
}

isPlainObject({})           // true
isPlainObject([])           // false
isPlainObject(new Date())   // false
isPlainObject(null)         // false
```

### 实际应用示例

#### 类型安全的函数参数处理

```javascript
function processData(data) {
  // 类型检查
  if (!Array.isArray(data)) {
    throw new TypeError('Expected an array');
  }
  
  return data.map(item => {
    if (typeof item !== 'object' || item === null) {
      return item;
    }
    return processItem(item);
  });
}
```

#### 通用类型判断工具函数

```javascript
const TypeChecker = {
  isString: (value) => typeof value === 'string',
  isNumber: (value) => typeof value === 'number' && !isNaN(value),
  isBoolean: (value) => typeof value === 'boolean',
  isArray: (value) => Array.isArray(value),
  isObject: (value) => Object.prototype.toString.call(value) === '[object Object]',
  isFunction: (value) => typeof value === 'function',
  isNull: (value) => value === null,
  isUndefined: (value) => typeof value === 'undefined',
  isDate: (value) => value instanceof Date,
  isRegExp: (value) => value instanceof RegExp,
  getType: (value) => Object.prototype.toString.call(value).slice(8, -1)
};
```

### 性能对比

不同方法的性能差异：

- **typeof**: 最快，适合基本类型判断
- **instanceof**: 较快，适合对象类型判断
- **Object.prototype.toString.call()**: 较慢，但最准确

### 最佳实践

1. **基本类型**: 使用 `typeof`
2. **数组**: 使用 `Array.isArray()`
3. **对象类型**: 使用 `Object.prototype.toString.call()`
4. **null/undefined**: 使用 `===` 或 `==`
5. **复杂判断**: 封装成工具函数，统一管理

### 总结

选择合适的类型判断方法对于编写健壮的 JavaScript 代码至关重要。理解各种方法的优缺点，根据具体场景选择最合适的方法，可以提高代码的可读性和可靠性。

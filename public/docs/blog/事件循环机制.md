---
slug: 事件循环机制
title: 事件循环机制
excerpt: 任务队列 事件监听
date: 2025-12-18
author: 小菜权
readTime: 1 分钟
tags: []
category: blog
image: https://picsum.photos/seed/193/1200/600
---

## JavaScript 事件循环机制

事件循环（Event Loop）是 JavaScript 实现异步编程的核心机制。理解事件循环对于掌握 JavaScript 的异步执行流程至关重要。

### 基本概念

JavaScript 是单线程语言，这意味着同一时间只能执行一个任务。为了处理异步操作，JavaScript 引擎使用了事件循环机制，通过任务队列来管理异步任务的执行。

### 执行栈和任务队列

#### 执行栈（Call Stack）

执行栈用于存储同步任务的执行上下文。当函数被调用时，会创建一个执行上下文并压入栈中；函数执行完毕后，执行上下文会从栈中弹出。

```javascript
function a() {
  console.log('a');
  b();
}

function b() {
  console.log('b');
}

a(); // 执行栈: [a] -> [a, b] -> [a] -> []
```

#### 任务队列（Task Queue）

任务队列用于存储异步任务的回调函数。当异步操作完成时，回调函数会被放入任务队列中等待执行。

### 宏任务和微任务

JavaScript 中的任务分为两类：

#### 宏任务（Macro Task）

- `setTimeout` / `setInterval`
- `setImmediate` (Node.js)
- I/O 操作
- UI 渲染

#### 微任务（Micro Task）

- `Promise.then()` / `Promise.catch()`
- `queueMicrotask()`
- `MutationObserver`
- `process.nextTick()` (Node.js)

### 事件循环执行流程

1. **执行同步代码**: 从执行栈顶部开始执行
2. **执行微任务**: 执行完所有微任务
3. **执行宏任务**: 从任务队列中取出一个宏任务执行
4. **重复步骤 2-3**: 继续执行微任务和宏任务

```javascript
console.log('1'); // 同步任务

setTimeout(() => {
  console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // 微任务
});

console.log('4'); // 同步任务

// 输出: 1, 4, 3, 2
```

### 实际应用示例

#### 示例 1: Promise 和 setTimeout

```javascript
console.log('start');

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise');
});

console.log('end');

// 输出: start, end, promise, timeout
```

**执行顺序说明**:
1. 执行同步代码: `start`, `end`
2. 执行微任务: `promise`
3. 执行宏任务: `timeout`

#### 示例 2: 嵌套的异步操作

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4');
  setTimeout(() => {
    console.log('5');
  }, 0);
});

console.log('6');

// 输出: 1, 6, 4, 2, 3, 5
```

### 事件监听

事件监听是浏览器中常见的异步操作模式：

```javascript
// 点击事件
button.addEventListener('click', () => {
  console.log('按钮被点击');
});

// 异步事件处理
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM 加载完成');
});
```

事件监听器也是通过事件循环机制执行的。当事件触发时，回调函数会被放入任务队列中等待执行。

### 常见问题

#### 1. 为什么 setTimeout 不准确？

```javascript
console.log('start');
setTimeout(() => {
  console.log('timeout');
}, 1000);
// 执行耗时操作
for (let i = 0; i < 1000000; i++) {
  // 耗时操作
}
console.log('end');
```

`setTimeout` 只是将回调函数放入任务队列，如果执行栈中有耗时操作，回调函数需要等待执行栈清空后才能执行。

#### 2. 如何确保代码在 DOM 更新后执行？

```javascript
// 使用 Promise
Promise.resolve().then(() => {
  // DOM 已更新
});

// 使用 queueMicrotask
queueMicrotask(() => {
  // DOM 已更新
});
```

### 性能优化建议

1. **避免阻塞主线程**: 将耗时操作放入 Web Worker
2. **合理使用微任务**: 微任务优先级高，适合处理高优先级任务
3. **避免过度嵌套**: 使用 async/await 替代回调嵌套
4. **批量处理**: 将多个 DOM 操作合并，减少重排重绘

### 总结

事件循环机制是 JavaScript 异步编程的基础，理解其工作原理有助于：

- 正确理解代码执行顺序
- 避免常见的异步陷阱
- 优化应用性能
- 编写更可靠的异步代码

掌握事件循环机制，是成为一名优秀 JavaScript 开发者的必备技能。

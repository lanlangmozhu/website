---
slug: 什么是跨域
title: 什么是跨域
excerpt: ## 跨域  #### 同源策略  ##### 协议 ##### 域名/主机 ##### 端口
date: 2025-12-18
author: 小菜权
readTime: 1 分钟
tags: []
category: blog
image: https://picsum.photos/seed/695/1200/600
---

## 什么是跨域

跨域（Cross-Origin）是 Web 开发中经常遇到的问题。当浏览器从一个域名的网页去请求另一个域名的资源时，如果协议、域名或端口不同，就会产生跨域问题。

### 同源策略

同源策略（Same-Origin Policy）是浏览器的一个安全机制，它限制了来自不同源的文档或脚本如何与当前文档进行交互。

#### 同源的定义

两个 URL 被认为是同源的，必须满足以下三个条件完全相同：

##### 1. 协议（Protocol）

- `http://` 和 `https://` 不同源
- `http://example.com` 和 `https://example.com` 不同源

##### 2. 域名/主机（Domain/Host）

- `example.com` 和 `www.example.com` 不同源
- `example.com` 和 `api.example.com` 不同源

##### 3. 端口（Port）

- `http://example.com` 和 `http://example.com:8080` 不同源
- 默认端口（80 和 443）需要明确指定

### 跨域示例

```javascript
// 同源 - 可以正常请求
fetch('http://example.com/api/data');

// 跨域 - 会被浏览器阻止
fetch('https://example.com/api/data'); // 协议不同
fetch('http://www.example.com/api/data'); // 域名不同
fetch('http://example.com:8080/api/data'); // 端口不同
```

### 跨域解决方案

#### 1. CORS（跨域资源共享）

CORS 是最常用的跨域解决方案，通过在服务器端设置响应头来允许跨域请求：

**服务器端设置**:

```javascript
// Express.js 示例
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*'); // 允许所有源
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

// 允许特定源
res.header('Access-Control-Allow-Origin', 'https://example.com');
```

**预检请求（Preflight）**:

对于复杂请求，浏览器会先发送 OPTIONS 请求：

```javascript
// 客户端发送复杂请求
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token'
  },
  body: JSON.stringify({ data: 'test' })
});
```

#### 2. JSONP

JSONP 利用 `<script>` 标签不受同源策略限制的特性：

```javascript
// 客户端
function handleResponse(data) {
  console.log(data);
}

const script = document.createElement('script');
script.src = 'https://api.example.com/data?callback=handleResponse';
document.body.appendChild(script);

// 服务器返回
handleResponse({ data: 'test' });
```

**缺点**: 只支持 GET 请求，安全性较低

#### 3. 代理服务器

通过同源的代理服务器转发请求：

```javascript
// 前端请求同源代理
fetch('/api/proxy', {
  method: 'POST',
  body: JSON.stringify({ url: 'https://api.example.com/data' })
});

// 服务器端代理
app.post('/api/proxy', async (req, res) => {
  const { url } = req.body;
  const response = await fetch(url);
  const data = await response.json();
  res.json(data);
});
```

#### 4. WebSocket

WebSocket 不受同源策略限制：

```javascript
const ws = new WebSocket('wss://api.example.com');
ws.onmessage = (event) => {
  console.log(event.data);
};
```

#### 5. postMessage

用于 iframe 之间的跨域通信：

```javascript
// 父页面
iframe.contentWindow.postMessage('data', 'https://example.com');

// iframe 页面
window.addEventListener('message', (event) => {
  if (event.origin === 'https://example.com') {
    console.log(event.data);
  }
});
```

### 常见跨域场景

#### 1. 前端开发环境

开发时前端运行在 `localhost:3000`，API 运行在 `localhost:8080`：

```javascript
// 解决方案：配置代理
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  }
};
```

#### 2. 第三方 API 调用

调用第三方 API 时遇到跨域问题：

```javascript
// 解决方案：使用 CORS 或代理
// 如果第三方 API 支持 CORS，直接调用
fetch('https://api.thirdparty.com/data');

// 如果不支持，使用自己的代理服务器
fetch('/api/proxy/thirdparty');
```

#### 3. 子域名通信

主域名和子域名之间的通信：

```javascript
// 解决方案：设置 document.domain
// 两个页面都设置
document.domain = 'example.com';

// 然后可以访问对方的 window 对象
```

### 安全注意事项

1. **不要使用 `Access-Control-Allow-Origin: *`**: 生产环境应该指定具体域名
2. **验证 Origin**: 服务器端应该验证请求来源
3. **使用 HTTPS**: 生产环境必须使用 HTTPS
4. **避免敏感信息**: 不要在 URL 中传递敏感信息

### 最佳实践

1. **优先使用 CORS**: 最标准和安全的方案
2. **配置合理的 CORS 策略**: 只允许必要的源、方法和头部
3. **使用代理服务器**: 当无法控制服务器端时
4. **避免 JSONP**: 除非必须支持旧浏览器

### 总结

跨域是 Web 开发中的常见问题，理解同源策略和掌握各种跨域解决方案，对于构建现代 Web 应用至关重要。选择合适的跨域方案，既能实现功能需求，又能保证应用的安全性。
